\documentclass{scrartcl}

\usepackage{fullpage}
\usepackage{url}

\author{
Luke Anderson, Jon Gjengset, Jeevana Inala, and Andrew Wang \\
\texttt{\{lukea,jfrg,jinala,wangaj\}@mit.edu}
}
\title{6.858 Project Report}
\subtitle{Concolic Execution for Django Applications}
\date{\today}

\begin{document}
\maketitle


\section{Motivation}

Concolic execution systems allow developers to verify security
invariants in their applications. This was demonstrated in Lab 3,
where the Z3 solver was used to find inputs that would trigger
inconsistencies in zoobar balances. Unfortunately, the lab's
framework is written specifically for the zoobar web application, and
would be difficult to adapt for testing any other application. We
therefore set out to provide an interface to concolic execution that
works for any web app built on top of the popular Django framework.


\section{Summary of results}

Our work is contained within two code repositories. These are
publicly available at:
\begin{itemize}
\item \url{https://github.com/jonhoo/django-zoobar}
\item \url{https://github.com/jonhoo/django-coex}
\end{itemize}

The first repository is a port of the zoobar application to Django.
This enables us to test our concolic framework with the proven Lab 3
version. Specifically, we demonstrate the same functionality and that
the same bugs are found in our version. To that end, we have attempted
to preserve the original application structure and code as much as
possible.

The second repository contains the modifications to the Lab 3 concolic
execution framework that allow us to support Django applications. Most
importantly, concolic inputs have to be preserved throughout the
complex internals of Django, so that they reach the application logic
intact. This is achieved in symex/symdjango.py, which replaces
symex/symflask.py from Lab 3. We found that our concolic inputs were
being lost in the parsing of URLs and POST form data, which is deeply
integrated into Django's codebase. Replacing those unsupported
operations allowed the concolic values to pass through to zoobar.

Since real web apps may have large databases, we considered various
options to exercise good coverage without exploding the number of
paths. We ended up implementing three different approaches in
symex/symqueryset.py: In addition to searching all database items as
in Lab 3, we also tried mutating the WHERE clause of SQL queries to
capture subtle edge cases, and dynamically inserting concolic values
in the database itself. These approaches all have their pros and cons,
and in the end, we allow the developer to choose which one to use.

With an eye towards large applications and the complexity of Django,
we also wanted to optimize the constraint-checking framework as much
as possible. Several optimizations were added to symex/fuzzer.py. Some
of these were drawn from KLEE~(Cadar, Dunbar, and Engler 2008), such
as removing implied constraints, and keeping a counter-example cache.
The most impactful optimization, though, was to avoid duplicate inputs
arising from different path conditions.

Use of our concolic framework by the developer is exemplified in
check-symex-zoobar.py, which was adapted from Lab 3. For reasons
explained in the Details section, the first step is to make explicit
the URLs to test and the database query method. Then, the test
function is defined similarly, using the same invariants as in Lab 3,
and the concolic tester is invoked on it. Using the default settings
of checking all database objects and turning on all optimizations, the
framework runs 48 iterations in approximately 30 seconds.

Finally, we also ran our concolic execution system on gradapply, which
is a real and a much complex website than zoobar. Since gradapply is
written in an older version of Django (1.6), we first extended our
system to support version 1.6. Then it was straightforward to adapt
the checking script. The system tests six different URL paths, and
completes in 77 iterations. In the time we had, we descoped writing
invariants and finding bugs in gradapply.

Contrary to what we initially thought, we did not have to modify the
Django codebase. This was made possible by the dynamic nature of
Python, which allowed us to overwrite or bypass methods that were
incompatible with concolic execution.


\section{Implementation details}

For each component of the project, we explain the design decisions
made and any challenges we faced in its subsection below.

\subsection{Preserving concolic values}

\begin{enumerate}
\item URL parsing in Django is based on nested regular expressions
  that are used both to determine which view should be invoked and to do reverse URL
lookups.
  Unfortunately, regular expressions are not supported by Z3, so we
  needed another way to make the choice of view and the input
  parameters concolic. The simplest solution we arrived at was to
  let the developer specify a mapping of URLs to views, along with
  named parameters. This was favored over calling all the views in an
  application directly, which is more automated, but would also
  bypass all the Django middleware modules that many applications
  rely on.

\item Web applications receive input from a number of sources: in-URL
  parameters, GET/POST parameters, file uploads, cookies, etc., and
  there is no simple way to automatically determine which of these an
  application cares about. For the scope of the project, we took the
  approach of requiring the developer to explicitly construct the
  datasets with concolic values and pass them in whenever a URL points
  to a relevant view. Future work could reduce the developer's burden
  in telling the framework about the format of these inputs.

\item So far, the concolic execution framework supports only a
  fraction of the vast set of Python operations available to Django
  and web apps. For zoobar, we spent considerable time locating
  unsupported operations in the Django codebase, such as POST form
  data and URL resolution, and finding ways to circumvent those
  operations. It is likely that there are still several corner cases
  in the Django codebase where concolic values are lost, but the best
  way to identify would be to continue testing on a diverse set of
  applications.
\end{enumerate}

\subsection{Handling database queries}

The challenging tradeoff we faced was to achieve good coverage
exposing the internal database query decisions, while retaining
efficiency. The ideal solution may be a hybrid approach that adapts to
situations, but for now, we discuss the strengths and weaknesses of
individual approaches

\begin{enumerate}
\item \underline{All:}
  This mirrors Lab 3, where we iterate over the objects returned by
  the database, comparing them to the lookup key. We extend Lab 3's
  implementation to support multiple key lookups, and lookups across
  related tables.

  This approach is relatively simple, and generally provides good
  coverage. However, it potentially re-tests the same branches of the programs, which is wasteful. Further, there are situations (described
  below in \underline{SQL}) where branches will not be covered.

\item \underline{Mutation:}
  We implemented a mutation approach based on ConSMutate~(Sarkar,
  et.\ al. 2012). The WHERE clause from database queries is extracted
  and mutated by changing the relational operator. For example, one
  might write $\textit{zoobars} > 10$ instead of $\textit{zoobars}
  \geq 10$. If running the mutated query yields a new result, then we
  add the symmetric difference of the two conditions as a new path
  constraint. The hope is that the new constraint will lead to a
  concrete value explores an untouched branch of the code. This
  approach has lower coverage but can potentially catch common
  programmer errors.

\item \underline{SQL:}
  Two obstacles prevent the following code from exploring both
  branches of the IF statement: \textit{users.person.zoobars} is not
  concolic, and there may be no user that has more than 5 zoobars.
  \begin{verbatim}user = User.objects.get(username='bob')
if user.person.zoobars > 5:
  # do something
else:
  # do something else\end{verbatim}
  Our solution is to map database object's properties to new concolic
  values, e.g., creating a new concolic int for
  \textit{user.person.zoobars} when \textit{user} is assigned. Then we
  we automatically create new database entries when Z3 generates
  concrete values that are absent, e.g., before we try an input where
  \textit{user.person.zoobars} is 7, we ensure that there is a
  database entry with that value. Compared to \underline{All}, we
  achieve slightly better coverage on zoobar in even fewer iterations.
  The downside is that in general, dynamically adding values to the
  database makes it more difficult to write program invariants.
\end{enumerate}

\subsection{Concolic optimizations}

The most expensive component of concolic execution is running the Z3
solver multiple times on each iteration. Improving runtime can be done
by reducing the number of iterations or reducing the time it takes to
solve each Z3 instance.

\begin{enumerate}
\item To reduce the number of iterations, we kept a record of previous
  inputs, in addition to previous paths as in Lab 3. Sometimes,
  different path conditions may yield the same solution, in which case
  the web app would process and identical request. Avoiding this
  repeat reduced zoobar's iterations from 89 to 81.

\item To reduce the complexity of the constraint programs sent to Z3,
  we detect when constraints are implied by others. This is done each
  time we extend a path condition by a new constraint. Note that
  determining implication itself is a constraint program, so to avoid
  running Z3 on these, we determined a set of syntactic rules, which
  capture most implications in zoobar that Z3 would have found. This
  further reduced the number of iterations to 75.

\item Sometimes a constraint program may not need to be solved if a
  solution has already been recorded in a counter-example cache. The
  cache does not eliminate any iterations, but the amortized runtime
  benefit of finding a solution in the cache may outweigh the cost of
  having to run the solver anyway. On zoobar, the counter-example
  cache was successfully employed 28 times.
\end{enumerate}

\end{document}
